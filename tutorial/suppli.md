# 補遺

エフェクト作成チュートリアルには書ききれなかった小ネタとか落とし穴とかを集めてみました  
まだ少ないけど増やしていく予定

## 小ネタ

### 実はJsonnet

json部分の記述はチュートリアル第一章で一言だけ書きましたが、純粋なjsonではなくてJsonnetという構成言語です。なので、`/*～*/`や`//`によるC++スタイルのコメントや、配列の最後の要素に`,`が付いててもエラー扱いされない、変数が使えるなど多くのメリットがあります。ただ、それがために[落とし穴](#jsonnetによるオブジェクトの暗黙のマージ)もありますけど

### パラメータに書ける物

jsonのパースに用いているcerealの特徴ですが、構造体を定義するとシリアライザとデシリアライザの作成までほぼ終わってしまうので、YRZFx.ixxの`FXTech`構造体を調べるとエフェクトに記述できる全パラメータについての情報が分かります。

リファレンスマニュアルも用意してありますから[見てください](../docs/html/index.html)。

### コントローラのpmxモデルをどう作るか

Subayaiのライトのように、エフェクトのコントローラになるpmxモデルに材質を付けてコントローラの材質注釈を元にエフェクトの挙動をコントロールする、というのはよく使われるシナリオです。

このようなモデルは材質が定義されている事が必要ですから、頂点が3つ以上含まれることになりますから、頂点はてきとうに遠くに置いたりしないとコントローラに設定されたポリゴンが無駄に画面に表示される事になってしまい、カッコ悪いです。かといってX=10000などとしてちょっと遠くに置くとレイトレーシングのパフォーマンスが落ちます。飛び地にポリゴンが置かれる状態にレイトレは弱いのです。1ポリゴンだけでも意外と露骨なフレームレートの落ち方をするので気になります。

そこでMikuMikuDayoでは**構成する全ての頂点の位置ベクトルの大きさが100000以上に設定されているモデルは一切表示されないモデル**として扱われ、レイトレーシングのためのオブジェクトも作らなくなりますので速度低下を免れます。ご活用ください。

本家MMDでは遠方クリッピング面までの距離が10万MMD、近方クリッピング面までの距離が1MMDとして設定されているため、それを数値の根拠としています。


### ポストプロセス起動用のpmxモデルは表示されない

ポストプロセスの起動元になっているpmxモデルも**一切表示されないモデル**としてMikuMikuDayoからは扱われます。


### 材質注釈とpass.conditionsには式を書ける

```
Roughness : 1.0
```

というような材質注釈があったとして

```
Roughness : 0.5*2
```

という具合に、式を書くことが出来ます。

```
Roughness : frac(Time)
```

関数や変数も使えます。使える組み込み関数・演算子については`Expr.ixx`を参照してください。変数はコンスタントバッファ`hlsl/cb.hlsli`に格納されている値を参照できます。

パスの起動条件を指定するpass.conditionsパラメータにも同様に式を書けます。

## 落とし穴

エフェクトを書いていると言語やフレームワーク独特のクセというものに引っかかる事が多々あります。そういうのを挙げてみました

### Jsonnetによるオブジェクトの暗黙のマージ

Jsonnetでは`{"foo":1} + {"bar":2}`というようにオブジェクトを+演算子でつなぐと`{"foo":1, "bar":2}`というマージされたオブジェクトが出来るのですが、困ったことに+演算子は省略できてしまいます

例えば、このようにpasses配列を定義したとして

```
"passes" : [
    { "name":"Pass1", "type":"postprocess", ... },
    { "name":"Pass2", "type":"compute", ... }
    { "name":"Pass3", "type":"raytracing", ... },
]
```

こう書いたとすると、Pass2は実行されません。Pass2の後の`,`が抜けているため、Pass2とPass3がマージされてPass2に含まれる重複要素はPass3の内容で上書きされ、以下のように認識されるからです

```
"passes" : [
    { "name":"Pass1", "type":"postprocess", ... },
    { "name":"Pass3", "type":"raytracing", ... }
]
```

ひでぇ罠もあったもんですが仕方ありません。ちゃんと書いてるしエラーも出ないのに意図通り動かない場合はFXDebugウィンドウのPassesの項目を見て、ちゃんと書いたパスが認識されているか調べるのも一つの手です。

### 1ch(モノクロ)テクスチャの取り扱い

PMXモデルに格納されているモノクロテクスチャは検出されるとRGBA4チャンネルのフォーマットに拡張され、Aチャンネルは1.0で埋められ、正しくグレースケールのテクスチャとして扱われます。

しかし、MatDescに指定されたモノクロテクスチャはRチャンネルだけが有効なテクスチャとして扱われるので、RGBAチャンネルがあるものとして読み込むと真っ赤なテクスチャになります。

どうしてMatDescのテクスチャには気を利かせないのかというと、ラフネスマップなどRチャンネルの読み取りだけで足りるテクスチャを作ったけどVRAMの使用量を気にして1チャンネルのテクスチャを使用しているのか、カラーに拡張してほしいけどモノクロテクスチャが指定されたのか判別できないためです。
